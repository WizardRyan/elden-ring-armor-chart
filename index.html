<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Elden Ring Armor Chart</title>
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <style>
            html{
                width: 100%;
                height: 100%;
            }
            body{
                width: 100%;
                height: 100%;
                margin:0;
                padding:0;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: rgb(255, 255, 255);
                color: #333;
            }

            .main-wrapper{
                display: flex;
                width: 100%;
                min-height: 100vh;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                padding: 20px;
                box-sizing: border-box;
            }
            
            .tick{
                font-size: 14px;
            }
            
            #graphic-container{
                display: flex;
                justify-content: center;
                align-items: center;
                background: rgba(255, 255, 255, 0.95);
                border-radius: 10px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
                padding: 20px;
                margin-bottom: 20px;
                max-width: 95vw;
                overflow: hidden;
            }

            #y-axis-label{
                transform: rotate(270deg);
                margin-right: 1500px;
                padding: 0;
                position: absolute;
                font-weight: bold;
            }

            #x-axis-label{
                margin-bottom: 30px;
                font-weight: bold;
            }

            svg{
                margin-left: 0px;
                max-width: 100%;
                height: auto;
            }

            #legend-div{
                margin-top: 20px;
            }

            #legend-div span{
                margin-right: 10px;
            }

            #input-div{
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
                justify-content: center;
                align-items: center;
                background: rgba(255, 255, 255, 0.95);
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
                max-width: 95vw;
                box-sizing: border-box;
            }

            .input-pair{
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 8px;
                min-width: 150px;
            }

            .input-pair span{
                font-weight: 600;
                color: #272727;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            select{
                padding: 10px 15px;
                border: 2px solid #e0e0e0;
                border-radius: 8px;
                background: white;
                font-size: 14px;
                font-weight: 500;
                color: #333;
                cursor: pointer;
                transition: all 0.3s ease;
                min-width: 120px;
            }

            select:hover{
                border-color: #667eea;
                box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
            }

            select:focus{
                outline: none;
                border-color: #667eea;
                box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            }

            #armor-type-div{
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 8px;
                min-width: 150px;
            }

            #armor-type-div span{
                font-weight: 600;
                color: #272727;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .tooltip{
                position: fixed;
                background: white;
                border: 1px solid #ddd;
                border-radius: 8px;
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                overflow-y: auto;
                overflow-x: auto;
                display: none;
                padding: 10px;
                pointer-events: none;
            }

            .tooltip::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }

            .tooltip::-webkit-scrollbar-track {
                background: #f1f1f1;
                border-radius: 4px;
            }

            .tooltip::-webkit-scrollbar-thumb {
                background: #667eea;
                border-radius: 4px;
            }

            .tooltip::-webkit-scrollbar-thumb:hover {
                background: #a8a8a8;
            }

            .armor-summary{
                padding: 10px;
                margin: 5px;
                background: #f9f9f9;
                border-radius: 6px;
                border-left: 4px solid #667eea;
                min-width: 200px;
            }

            .armor-summary img{
                display: block;
                margin: 0 auto 10px auto;
                border-radius: 4px;
            }

            .armor-summary p{
                margin: 4px 0;
                font-size: 13px;
                line-height: 1.4;
            }

            .tooltip-info{
                display: flex;
                flex-direction: column;
                width: 100px;
            }

            /* Responsive adjustments */
            @media screen and (max-width: 1400px) {
                #graphic-container {
                    padding: 15px;
                }
                
                svg {
                    width: 100%;
                    max-width: 1200px;
                }
            }

            @media screen and (max-height: 900px) {
                .main-wrapper {
                    min-height: auto;
                    padding: 10px;
                }
                
                #graphic-container {
                    margin-bottom: 15px;
                }
            }

            @media screen and (max-width: 768px) {
                #input-div {
                    flex-direction: column;
                    gap: 15px;
                }
                
                .input-pair {
                    min-width: 200px;
                }
            }
            
        </style>

        <script src="d3.v7.js"></script>
        <script type="module">

            let data = await d3.csv("./data/armors.csv"); 
            console.log('freshly read in data:');
            
            let axisOptions = ['Phy','Strike','Slash','Pierce','Magic','Fire','Ligt','Holy', "weight", 'Immunity','Robustness','Focus','Vitality','Poise'];
            //column on the left
            let infoOptions = ['name', 'Phy','Strike','Slash','Pierce','Magic','Fire','Ligt','Holy', "weight", 'Immunity','Robustness','Focus','Vitality','Poise'];
            let infoElements = [];
            
            //"Gauntlet" may be for an outlier or invalid point, need to investigate"
            let armorTypes = ["All", "Chest Armor", "Leg Armor", "Gauntlets", "Helm", "Gauntlet"];
                        
            const graphicContainer = document.getElementById("graphic-container");
            const yAxisContainer = document.getElementById("y-axis-container");
            const inputDiv = document.getElementById("input-div");
            
            //dropdowns for each axis
            const populateAxisDropdown = (selectElement) => {
                    for(const option of axisOptions){
                    let optionText = option;
                    if(option == "Ligt") optionText = "Lightning";
                    if(option == "Phy") optionText = "Physical";
                    if(option == "weight") optionText = "Weight";
                    const optionElement = document.createElement("option");
                    optionElement.value = option;
                    optionElement.innerText = optionText;
                    selectElement.appendChild(optionElement);
                }
            }

            const xSelect = document.createElement("select");
            xSelect.setAttribute("class", "x-select");
            const ySelect = document.createElement("select");
            populateAxisDropdown(xSelect);
            populateAxisDropdown(ySelect);

            const addDropDown = (element, text) => {
                const container = document.createElement("div");
                container.setAttribute("class", "input-pair");
                const label = document.createElement("span");
                label.innerText = text;
                container.appendChild(label);
                container.appendChild(element);
                inputDiv.appendChild(container);
            }

            addDropDown(xSelect, "X axis:");
            addDropDown(ySelect, "Y axis:");

            //be able to filter armor types
            const armorTypeDiv = document.createElement("div");
            armorTypeDiv.id = "armor-type-div";
            const armorTypeSpan = document.createElement("span");
            armorTypeSpan.innerText = "Filter Armor Types:";
            const armorTypeSelect = document.createElement("select");
            for(const option of armorTypes){
                const optionElement = document.createElement("option");
                optionElement.value = option;
                optionElement.innerText = option;
                armorTypeSelect.appendChild(optionElement);
            }
            armorTypeDiv.appendChild(armorTypeSpan);
            armorTypeDiv.appendChild(armorTypeSelect)
            inputDiv.appendChild(armorTypeDiv);
            
            //parse data to usable formats
            for(const row of data){
                row.dmgNegation = row.dmgNegation.replace(/'/g, `"`);
                row.dmgNegation = JSON.parse(row.dmgNegation);
                row.resistance = row.resistance.replace(/'/g, `"`);
                row.resistance = JSON.parse(row.resistance);
                row.weight = parseFloat(row.weight)
                for(const property of axisOptions.filter(o => o != "weight")){
                    try{
                        row[property] = row.dmgNegation.find((o) => o.name == property).amount;
                    }
                    catch(err){
                        try{
                            row[property] = row.resistance.find(o => o.name == property).amount;
                        }
                        catch(err){
                            row[property] = 0;
                        }
                    }
                }
                try{
                    // replace images with local data if possible
                    row.image = row.image.replace("https://eldenring.fanapis.com/images/armors/", "data/armorImages/");
                }
                catch(err){
                    
                }
            }
            console.log(data);           

            const fullData = Array.from(data);
            
            // Make dimensions responsive
            const getResponsiveDimensions = () => {
                const containerWidth = Math.min(window.innerWidth * 0.9, 2000);
                const containerHeight = Math.min(window.innerHeight * 0.8, 1200);
                
                return {
                    margin: {top: 30, right: 30, bottom: 70, left: 100},
                    width: containerWidth - 130, // account for margins
                    height: containerHeight - 100
                };
            };

            let dimensions = getResponsiveDimensions();
            let { margin, width, height } = dimensions;

            // Update dimensions on window resize
            window.addEventListener('resize', () => {
                dimensions = getResponsiveDimensions();
                margin = dimensions.margin;
                width = dimensions.width;
                height = dimensions.height;
                
                // Update SVG dimensions
                svg.attr("width", width + margin.left + margin.right)
                   .attr("height", height + margin.top + margin.bottom);
                
                // Update scales and redraw
                x.range([0, width]);
                y.range([height, 0]);
                xAxis.attr("transform", `translate(0, ${height})`);
                
                genericChange();
            });

            //append the svg object to the body of the page
            const svg = d3.select("#graphic-container")
            .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
            //give some space for y margin
            .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // X axis
            const x = d3.scaleLinear()
            .range([0, width ]);            
            //make sure the text is below the x axis by appending to a translated group
            const xAxis = svg.append("g")
            .attr("transform", `translate(0, ${height})`);

            //Add Y axis
            const y = d3.scaleLinear()
            .range([ height, 0]);

            const yAxis = svg.append("g").attr("class", "y-axis");

            let tooltipSpan = document.createElement("div");
            tooltipSpan.setAttribute("class", "tooltip");
            console.log(`max width: ${getResponsiveDimensions().width}`);
            document.body.appendChild(tooltipSpan);
            tooltipSpan.style.maxWidth = `${Math.floor(getResponsiveDimensions().width)}px`;

            onwheel = (event) => {
                const scrollAmount = 100;
                if(event.deltaY > 0){
                    tooltipSpan.scrollLeft += scrollAmount;
                }
                else{
                    tooltipSpan.scrollLeft -= scrollAmount;
                }
             }


            // Improved tooltip positioning function
            const positionTooltip = (mouseX, mouseY, tooltipElement) => {
                const tooltipRect = tooltipElement.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                let left = mouseX + 20;
                let top = mouseY - 40;
                
                // Check horizontal overflow
                if (left + tooltipRect.width > viewportWidth) {
                    left = mouseX - tooltipRect.width - 20;
                }
                
                // If still overflowing (tooltip too wide), position at edge
                if (left < 0) {
                    left = 10;
                }
                if (left + tooltipRect.width > viewportWidth) {
                    left = viewportWidth - tooltipRect.width - 10;
                }
                
                // Check vertical overflow
                if (top + tooltipRect.height > viewportHeight) {
                    top = viewportHeight - tooltipRect.height - 10;
                }
                if (top < 0) {
                    top = 10;
                }
                
                tooltipElement.style.left = left + 'px';
                tooltipElement.style.top = top + 'px';
            };

            let tooltipImage = document.createElement("img");
            tooltipImage.onmouseout = () => {
                // console.log(`move out of image`);
                tooltipSpan.style.display = "none";
                for(const prop in axisOptions){
                    try{
                        let el = document.getElementById(`propId${prop}`);
                        el.innerHTML = `${prop}: 0`;
                    }
                    catch(err){

                    }
                }
            }
            tooltipImage.setAttribute("src", "./data/armorImages/image.svg");
            tooltipImage.style.maxWidth = "200px";
            tooltipSpan.appendChild(tooltipImage);

            const updateChart = (xVal, yVal) => {

                let medianX = d3.median(data, d => d[xVal]);
                
                // Update the X axis
                x.domain(d3.extent(data, d => d[xVal]));
                xAxis
                .transition()
                .duration(1000)
                .call(d3.axisBottom(x))
                
                let xMedianLoc = x(medianX);
                svg.append("rect")
                .attr("x", xMedianLoc)
                .attr("y", margin.top)
                .attr("width", "1px")
                .attr("height", height)
                .attr("class", "median-gizmo")
                .attr("fill", "rgba(1, 1, 1, 0.5)");

                svg.append("text")
                .attr("x", xMedianLoc)
                .attr("y", margin.top + height + 15)
                .attr("class", "median-gizmo")
                .text(`Median`);

                // Update the Y axis
                let medianY = d3.median(data, d => d[yVal]);
                y.domain(d3.extent(data, d => d[yVal]));
                yAxis.call(d3.axisLeft(y));

                let yMedianLoc = y(medianY);
                svg.append("rect")
                .attr("x", 0)
                .attr("y", yMedianLoc)
                .attr("width", width)
                .attr("height", "1px")
                .attr("class", "median-gizmo")
                .attr("fill", "rgba(1, 1, 1, 0.5)");

                svg.append("text")
                .attr("x", -90)
                .attr("y", yMedianLoc)
                .attr("class", "median-gizmo")
                .text(`Median`);

                let imageDimensions = 20;
                let imageWidth = imageDimensions;
                let imageHeight = imageDimensions;

                //placeholder dot in case image doesn't render
                svg.selectAll(".dot")
                .data(data)
                .join("circle")
                .attr("class","dot")
                .transition()
                .duration(1000)
                .attr("cx", d => x(d[xVal]))
                .attr("cy", d => y(d[yVal]))
                .attr("r", 4)
                .attr("fill", "#2f41b5");

                svg.selectAll("image")
                .data(data)
                .join("svg:image")
                .attr("class",".armor-image")
                .transition()
                .duration(1000)
                .attr("x", d => x(d[xVal]) - imageWidth /2)
                .attr("y", d => y(d[yVal]) - imageHeight /2)
                .attr("width", imageWidth)
                .attr("height", imageHeight)
                .attr("href", d => d.image)
                .attr("alt", "image.svg");

                //set hover zone
                svg.selectAll(".dotHover")
                .data(data)
                .join("circle")
                .on("mouseenter", (e, d) => {

                    const sameX = data.filter(other => other[xVal] === d[xVal]);
                    const sameY = data.filter(other => other[yVal] === d[yVal]);
                    const allAtPoint = sameX.filter(other => sameY.includes(other));

                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    
                    tooltipSpan.style.display = "flex";
                    tooltipSpan.style.position = "fixed";

                    // Clear previous content
                    tooltipSpan.innerHTML = "";

                    allAtPoint.forEach(item => {
                        const armorSummary = document.createElement('div');
                        armorSummary.className = 'armor-summary';
                        
                        const itemImage = document.createElement('img');
                        itemImage.setAttribute("src", item.image);
                        itemImage.style.maxWidth = "200px";
                        itemImage.style.maxHeight = "200px";
                        armorSummary.appendChild(itemImage);

                        for (const prop of infoOptions) {
                            const el = document.createElement("p");
                            el.innerHTML = `${prop}: <b>${item[prop]}</b>`;
                            armorSummary.appendChild(el);
                        }
                        tooltipSpan.appendChild(armorSummary);
                    });

                    // Position tooltip after content is added
                    setTimeout(() => {
                        positionTooltip(mouseX, mouseY, tooltipSpan);
                    }, 0);

                })
                .on("mouseout", () => {
                    tooltipSpan.style.display = "none";
                })
                .attr("class","dotHover")
                .attr("cx", d => x(d[xVal]))
                .attr("cy", d => y(d[yVal]))
                .attr("r", 8)
                .attr("fill", "rgba(0, 0, 0, 0)");

            }

            let genericChange = () => {
                svg.selectAll(".median-gizmo").remove();
                updateChart(xSelect.value, ySelect.value);
            }

            ySelect.onchange = genericChange;
            xSelect.onchange = genericChange;

            ySelect.value = "Phy";
            xSelect.value = "weight";
            armorTypeSelect.onchange = () => {
                data = (armorTypeSelect.value == "All") ? fullData : fullData.filter(d => d.category == armorTypeSelect.value);
                svg.selectAll("image").remove();
                svg.selectAll(".dotHover").remove();
                svg.selectAll(".dot").remove();

                genericChange();
            };

            updateChart("weight", ySelect.value);

            const yAxisTxt = document.getElementById("y-axis-label");
            const xAxisTxt = document.getElementById("x-axis-label");
        </script>
    </head>
    <body>
        <div class="main-wrapper">
            <div id="graphic-container">
                <div id="y-axis-container">
                </div>
            </div>
            <div id="input-div">
            </div>
        </div>
    </body>
</html>